
buttonHeight = 35

-- buttonWidth = 333

buttonSpacing = 3
buttonStroke = 2
buttonStrokeHalf = buttonStroke / 2

screenHeight = 612
screenWidth = 1024

buttonsPerLine = 4
buttonWidth = (screenWidth / buttonsPerLine) - (buttonSpacing * (buttonsPerLine-1))+ (buttonStrokeHalf * buttonsPerLine)

radarScale = 110
radarFullScreenScale = 50

screens = {}
databank = nill
warpdrive = nill
core = nill

warpDriveDestinationPlanet = nill

updateInterval = 1
updateMouseInterval = 0.05
updateHoverInterval = 0.05

shipWeight = 0


function initializeScreen(key, screenUnit)
	return {
		screen = screenUnit,
		id = screenUnit.getId(),
		slot = key,
		angle = -1,
		pitch = 0,
		yaw = 0,
		scale =  1,
		mapCenterPoint = {x = 0, y = 0, z = 0},
		screenCenterX = screenWidth / 2,
		screenCenterY = screenHeight - (screenHeight / 3),
		mapViewState = 1,
		extraWeight = 0,
		weightButtonClicked = nill,
		timer = 0,
		changeView = true,
		mouseDown = false,
		selectedPlanet = nill,
		hover = nill,
		zoomScale = 1.5,
		targetZoomScale = 1.5}
end

for key, value in pairs(unit) do
	if type(value) == "table" and type(value.export) == "table" then
		if value.getElementClass then
			if value.getElementClass() == "ScreenUnit" then
				screens[#screens + 1] = initializeScreen(key, value)
			elseif value.getElementClass() == "DataBankUnit" then
				databank = value
			elseif value.getElementClass() == "WarpDriveUnit" then
				warpdrive = value
			elseif value.getElementClass() == "CoreUnitDynamic" then
				core = value
			elseif value.getElementClass() == "CoreUnitStatic" then
				core = value
			end
		end
	end
end

presets = {}

function addPreset(preset)
	presets[#presets+1] = preset
end


-- #1
addPreset({
	backGroundColor = "0c0f09",
	pathColor = "999999",
	planetOffsetColor = "ffffff",
	buttonBorderColor = "2c2c2c",
	buttonBorderHoverColor = "ffffff",
	buttonBInactiveColor = "ff6700",
	buttonTInactiveColor = "d2d1d1",
	buttonBActiveColor = "fc7b24",
	buttonTActiveColor = "b1b1b1",
	buttonTWarpInactiveColor = "D0AF40",
	buttonTWarpActiveColor = "b1b1b1",
	mapCircleColor = "9e9e9e",
	mapBCircleColor = "a08787",
	mapConstructColor = "00ff00",
	mapConstructSColor = "440044",
	planetColor = "ffffff",
	planetEdgeColor = "ffffff",
	planetNameColor = "ff6700",
	miniTextColor = "ff6700",
	warpCostColor = "fc7b24"})

-- #2
addPreset({
	backGroundColor = "DFDFDF",
	pathColor = "999999",
	planetOffsetColor = "2c2c2c",
	buttonBorderColor = "2c2c2c",
	buttonBorderHoverColor = "ffffff",
	buttonBInactiveColor = "4B4B4B",
	buttonTInactiveColor = "d2d1d1",
	buttonBActiveColor = "c5c5c5",
	buttonTActiveColor = "515151",
	buttonTWarpInactiveColor = "D0AF40",
	buttonTWarpActiveColor = "756326",
	mapCircleColor = "2c2c2c",
	mapBCircleColor = "2c2c2c",
	mapConstructColor = "6f6f6f",
	mapConstructSColor = "404040",
	planetColor = "424242",
	planetEdgeColor = "4b4b4b",
	planetNameColor = "2c2c2c",
	miniTextColor = "161616",
	warpCostColor = "161616"})

-- #3
addPreset({
	backGroundColor = "031333",
	pathColor = "999999",
	planetOffsetColor = "82e0ff",
	buttonBorderColor = "2c2c2c",
	buttonBorderHoverColor = "68b3cc",
	buttonBInactiveColor = "68b3cc",
	buttonTInactiveColor = "5d3c00",
	buttonBActiveColor = "335c69",
	buttonTActiveColor = "a66c02",
	buttonTWarpInactiveColor = "595601",
	buttonTWarpActiveColor = "bdb603",
	mapCircleColor = "9e9e9e",
	mapBCircleColor = "a08787",
	mapConstructColor = "00ff00",
	mapConstructSColor = "440044",
	planetColor = "1b708c",
	planetEdgeColor = "000000",
	planetNameColor = "82e0ff",
	miniTextColor = "82e0ff",
	warpCostColor = "5fd6fd"})

-- #4
addPreset({
	backGroundColor = "000000",
	pathColor = "ffffff",
	planetOffsetColor = "ffffff",
	buttonBorderColor = "2c2c2c",
	buttonBorderHoverColor = "ffffff",
	buttonBInactiveColor = "151515",
	buttonTInactiveColor = "ffffff",
	buttonBActiveColor = "232323",
	buttonTActiveColor = "ffffff",
	buttonTWarpInactiveColor = "909090",
	buttonTWarpActiveColor = "909090",
	mapCircleColor = "ffffff",
	mapBCircleColor = "cfcfcf",
	mapConstructColor = "00ff00",
	mapConstructSColor = "440044",
	planetColor = "4a4ed7",
	planetEdgeColor = "ffffff",
	planetNameColor = "ffffff",
	miniTextColor = "ffffff",
	warpCostColor = "ffffff"})
-- #5
addPreset({
	backGroundColor = "000000",
	pathColor = "ffffff",
	planetOffsetColor = "ffffff",
	buttonBorderColor = "2c2c2c",
	buttonBorderHoverColor = "4a4ed7",
	buttonBInactiveColor = "ffffff",
	buttonTInactiveColor = "151515",
	buttonBActiveColor = "ffffff",
	buttonTActiveColor = "232323",
	buttonTWarpInactiveColor = "1d1c1c",
	buttonTWarpActiveColor = "373030",
	mapCircleColor = "ffffff",
	mapBCircleColor = "cfcfcf",
	mapConstructColor = "00ff00",
	mapConstructSColor = "440044",
	planetColor = "4a4ed7",
	planetEdgeColor = "ffffff",
	planetNameColor = "ffffff",
	miniTextColor = "ffffff",
	warpCostColor = "ffffff"})
-- #6
addPreset({
	backGroundColor = "3c6553",
	pathColor = "ffffff",
	planetOffsetColor = "2c2c2c",
	buttonBorderColor = "2c2c2c",
	buttonBorderHoverColor = "ffffff",
	buttonBInactiveColor = "070b0a",
	buttonTInactiveColor = "3c6553",
	buttonBActiveColor = "3c6553",
	buttonTActiveColor = "070b0a",
	buttonTWarpInactiveColor = "1d1c1c",
	buttonTWarpActiveColor = "1d1c1c",
	mapCircleColor = "ffffff",
	mapBCircleColor = "cfcfcf",
	mapConstructColor = "00ff00",
	mapConstructSColor = "440044",
	planetColor = "3c6553",
	planetEdgeColor = "ffffff",
	planetNameColor = "0d1311",
	miniTextColor = "0d1311",
	warpCostColor = "0d1311"})
-- #7
addPreset({
	backGroundColor = "070b0a",
	pathColor = "ffffff",
	planetOffsetColor = "ffffff",
	buttonBorderColor = "2c2c2c",
	buttonBorderHoverColor = "ffffff",
	buttonBInactiveColor = "3c6553",
	buttonTInactiveColor = "070b0a",
	buttonBActiveColor = "070b0a",
	buttonTActiveColor = "3c6553",
	buttonTWarpInactiveColor = "1d1c1c",
	buttonTWarpActiveColor = "808080",
	mapCircleColor = "ffffff",
	mapBCircleColor = "cfcfcf",
	mapConstructColor = "00ff00",
	mapConstructSColor = "440044",
	planetColor = "ffffff",
	planetEdgeColor = "ffffff",
	planetNameColor = "3c6553",
	miniTextColor = "3c6553",
	warpCostColor = "3c6553"})
-- #8
addPreset({
	backGroundColor = "00001e",
	pathColor = "ffffff",
	planetOffsetColor = "025a6e",
	buttonBorderColor = "2c2c2c",
	buttonBorderHoverColor = "ffffff",
	buttonBInactiveColor = "025a6e",
	buttonTInactiveColor = "fba71d",
	buttonBActiveColor = "fba71d",
	buttonTActiveColor = "025a6e",
	buttonTWarpInactiveColor = "1d1c1c",
	buttonTWarpActiveColor = "04d8d7",
	mapCircleColor = "ffffff",
	mapBCircleColor = "cfcfcf",
	mapConstructColor = "00ff00",
	mapConstructSColor = "440044",
	planetColor = "0d71d3",
	planetEdgeColor = "ffffff",
	planetNameColor = "816d32",
	miniTextColor = "816d32",
	warpCostColor = "816d32"})
-- #9
addPreset({
	backGroundColor = "060000",
	pathColor = "ff4b00",
	planetOffsetColor = "025a6e",
	buttonBorderColor = "b20000",
	buttonBorderHoverColor = "ffffff",
	buttonBInactiveColor = "100000",
	buttonTInactiveColor = "aa0000",
	buttonBActiveColor = "280101",
	buttonTActiveColor = "aa0000",
	buttonTWarpInactiveColor = "c51d1d",
	buttonTWarpActiveColor = "c51d1d",
	mapCircleColor = "ff0000",
	mapBCircleColor = "ff0000",
	mapConstructColor = "00ff00",
	mapConstructSColor = "440044",
	planetColor = "001aff",
	planetEdgeColor = "ffffff",
	planetNameColor = "ff0000",
	miniTextColor = "ff0000",
	warpCostColor = "ff0000"})



mapCircleThickness = 0.8 --export: Defines circle thickness. Default: 0.8
mapCircleThickness =  mapCircleThickness.."vh"

showSafeZone = false --export: Shows or hides safe zone bubble




local presetButton = {width = buttonHeight, height = buttonHeight, y= buttonSpacing + ((buttonHeight+buttonSpacing+buttonStrokeHalf) * (12 / buttonsPerLine)), x=buttonSpacing, preset = 1}


function saveAll()
	if databank then
		savepreset()
		for _,screenObject in ipairs(screens) do
			save(screenObject)
		end
		if (core.getConstructMass() / 1000 > 3) then
			databank.setFloatValue("shipWeight", math.floor(core.getConstructMass() / 1000))
		end
	end
end

function savepreset()
	if databank then
		databank.setIntValue("warpPreset", presetButton.preset)
	end
end



function split(s, delimiter)
	result = {};
	for match in (s..delimiter):gmatch("(.-)"..delimiter) do
		table.insert(result, match);
	end
	return result;
end

if databank then
	for _,key in ipairs(json.decode(databank.getKeys())) do
		value = databank.getFloatValue(key)

		--		if key == "shipWeight" then
		--			shipWeight = value
		--		elseif key == "showSafeZone" then
		--			if value == 1 then
		--				showSafeZone = true
		--			else
		--				showSafeZone = false
		--			end
		--		end

		for _,screenObject in ipairs(screens) do
			if string.match(key, screenObject.slot) then

				splitted = split(key, "_")
				lastPart = splitted[#splitted]

				if lastPart == "angle" then
					screenObject.angle = value
				elseif lastPart == "pitch" then
					screenObject.pitch = value
				elseif lastPart == "zoomScale" then
					screenObject.zoomScale = value
				elseif lastPart == "yaw" then
					screenObject.yaw = value
				elseif lastPart == "state" then
					screenObject.mapViewState = value
				elseif lastPart == "weight" then
					shipWeight = value
				end
			end
		end
	end

	if databank.hasKey("shipWeight") then
		shipWeight = math.floor(databank.getFloatValue("shipWeight"))
	end


	if databank.hasKey("warpPreset") then
		presetButton.preset = databank.getIntValue("warpPreset")
		if presetButton.preset < 1 then
			presetButton.preset = 1
		end
	end

end

preset =  presets[1]

function updatePreset()
	if #presets < presetButton.preset or presetButton.preset < 1 then
		preset =  presets[1]
		return
	end
	preset =  presets[presetButton.preset]
end
updatePreset()

function Split(s, delimiter)
	result = {};
	for match in (s..delimiter):gmatch("(.-)"..delimiter) do
		table.insert(result, match);
	end
	return result;
end



function save(screenObject)
	if databank then
		databank.setFloatValue(screenObject.slot.."_angle", screenObject.angle)
		databank.setFloatValue(screenObject.slot.."_pitch", screenObject.pitch)
		databank.setFloatValue(screenObject.slot.."_yaw", screenObject.yaw)
		databank.setFloatValue(screenObject.slot.."_zoomScale", screenObject.zoomScale)
		databank.setFloatValue(screenObject.slot.."_state", screenObject.mapViewState)
	end
end


weightScreenButtons = {}

local amountButton = {id = #weightScreenButtons, width = 80, y=screenHeight-buttonHeight-buttonSpacing, x=screenWidth - 80 -10, change = 100}
table.insert(weightScreenButtons, amountButton)
local amountButton = {id = #weightScreenButtons, width = 60, y=amountButton.y, x=amountButton.x- 60 -3, change = 10}
table.insert(weightScreenButtons, amountButton)
local amountButton = {id = #weightScreenButtons, width = 50, y=amountButton.y, x=amountButton.x- 50 -3, change = -10}
table.insert(weightScreenButtons, amountButton)
local amountButton = {id = #weightScreenButtons, width = 70, y=amountButton.y, x=amountButton.x- 70 -3, change = -100}
table.insert(weightScreenButtons, amountButton)

function getMoonsCount(planet)
	counter = ""
	for index in pairs(planet.moons) do
		counter = counter.."*"
	end
	return counter
end

function formatPlanetName(planet)
	return planet.name..getMoonsCount(planet)
end

function mapX(planet)
	return planet.center.x/400000
end

function mapY(planet)
	return (planet.center.y/400000)
end

function mapZ(planet)
	return (planet.center.z)/400000
end

planets = {}

-- creating planet button and assingning it to planet object
function addPlanetButton(planet)

	local x = 0
	local y = 0


	local line = math.floor(#planets / buttonsPerLine)
	local place = #planets % buttonsPerLine

	buttonX = buttonSpacing + ((buttonWidth+buttonSpacing+buttonStrokeHalf) * place)
	buttonY = buttonSpacing + ((buttonHeight+buttonSpacing+buttonStrokeHalf) * line)

	button = {id = #planets + 1, planet = planet, name = formatPlanetName(planet), x=buttonX, y=buttonY}
	planet.button = button
	planet.mapCoords = {x = mapX(planet),y = mapY(planet), z = mapZ(planet)}
	planet.fullname = planet.name
	table.insert(planets, planet)
end

--::pos{0,0,13855453,7385167,-38337}
--::pos{0,0,13771471,7435803,-128971}
safeZoneCenter = vec3(13771471 / 400000, 7435803 / 400000, -128971 / 400000)

--edge = vec3(-2630938.1075 / 400000, 22487.5022 / 400000, -190192.7468 / 400000)

-- safe zone edge ::pos{0,0,-2630938.1075,22487.5022,-190192.7468}
-- Safe zone radius 90SU

safeZoneSize = 27.3*2

SU100 = 30*2



-- Moons
-- Madis
local MadisMoon1 = {name = "Moon 1", center = vec3(17448118.224,22966846.286,143078.820), radius = 10000}
local MadisMoon2 = {name = "Moon 2", center = vec3(17194626.000,22243633.880,-214962.810), radius = 11000}
local MadisMoon3 = {name = "Moon 3", center = vec3(17520614.000,22184730.000,-309989.990), radius = 15005}

-- Alioth
local AliothMoon1 = {name = "Moon 1", center = vec3(457933.000,-1509011.000,115524.000), radius = 30000}
local AliothMoon4 = {name = "Moon 4", center = vec3(-1692694.000,729681.000,-411464.000), radius = 30330}
local Sanctuary = {name = "Sanctuary", center = vec3(-1404835.000,562655.000,-285074.000), radius = 83400}

-- Thades
local ThadesMoon1 = {name = "Moon 1",center = vec3(29214402.000,10907080.695,433858.200), radius = 14002}
local ThadesMoon2 = {name = "Moon 2",center = vec3(29404193.000,10432768.000,19554.131), radius = 15000}

-- Talemai
local TalemaiMoon1 = {name = "Moon 1",center = vec3(-13058408.000,55781856.000,740177.760), radius = 15000}
local TalemaiMoon2 = {name = "Moon 2",center = vec3(-13503090.000,55594325.000,769838.640), radius = 12000}
local TalemaiMoon3 = {name = "Moon 3",center = vec3(-12800515.000,55700259.000,325207.840), radius = 11000}

-- Feli
local FeliMoon1 = {name = "Moon 1",center = vec3(-43902841.780,22261034.700,-48862386.000), radius = 14000}

-- Sinnen
local SinnenMoon1 = {name = "Moon 1",center = vec3(58969616.000,29797945.000,57969449.000), radius = 17000}

-- Lacobus
local LacobusMoon1 = {name = "Moon 1",center = vec3(99180968.000,-13783862.000,-926156.400), radius = 18000}
local LacobusMoon2 = {name = "Moon 2",center = vec3(99250052.000,-13629215.000,-1059341.400), radius = 14000}
local LacobusMoon3 = {name = "Moon 3",center = vec3(98905288.170,-13950921.100,-647589.530), radius = 15000}

-- Ion
local IonMoon1 = {name = "Moon 1",center = vec3(2472916.800,-99133747.000,-1133582.800), radius = 11000}
local IonMoon2 = {name = "Moon 2",center = vec3(2995424.500,-99275010.000,-1378480.700), radius = 15000}

-- Planets
addPlanetButton({name = "Alioth", center = vec3(-8.000, -8.000, -126303.000), radius = 126068, color = "#4d5861", moons = {AliothMoon1, AliothMoon4, Sanctuary}})
addPlanetButton({name = "Madis", center = vec3(17465536.000, 22665536.000, -34464.000), radius = 44300, color = "#777bbf", moons = {MadisMoon1, MadisMoon2, MadisMoon3}})
addPlanetButton({name = "Thades", center = vec3(29165536.000, 10865536.000, 65536.000), radius = 49000, color = "#da985f", moons = {ThadesMoon1, ThadesMoon2}})
addPlanetButton({name = "Ion", center = vec3(2995424.500,-99275010.000,-1378480.700), radius = 44950, color = "#9fc1df", moons = {IonMoon1, IonMoon2}})
addPlanetButton({name = "Sinnen", center = vec3(58665536.000, 29665536.000, 58165536.000), radius = 54950, color = "#d0885b", moons = {SinnenMoon1}, drawZero = true})
addPlanetButton({name = "Jago", center = vec3(-94134464.000, 12765536.000, -3634464.000), radius = 61590, color = "#36444f", moons = {}})
addPlanetButton({name = "Symeon", center = vec3(14165536.000, -85634464.000, -934464.000), radius = 49050, color = "#cad1d9", moons = {}})
addPlanetButton({name = "Lacobus", center = vec3(98865536.000, -13534464.000, -934464.000), radius = 55650, color = "#deedf9", moons = {LacobusMoon1, LacobusMoon2, LacobusMoon3}})
addPlanetButton({name = "Teoma", center = vec3(80865536.000, 54665536.000, -934464.000), radius = 62000, color = "#3e5268", moons = {}})
addPlanetButton({name = "Feli", center = vec3(-43534464.000, 22565536.000, -48934464.000), radius = 60000, color = "#928370", moons = {FeliMoon1}, drawZero = true})
addPlanetButton({name = "Talemai", center = vec3(-13234464.000, 55765536.000, 465536.000), radius = 57450, color = "#929482", moons = {TalemaiMoon1, TalemaiMoon2, TalemaiMoon3}})
addPlanetButton({name = "Sicari", center = vec3(52765536.000, 27165536.000, 52065536.000), radius = 51100, color = "#b78a64", moons = {}, drawZero = true})



buttonLowY = button.y

-- creating moon buttons
place = 1
for i, planet in ipairs(planets) do
	if #planet.moons > 0 then
		shift = 1
		extraX = -(buttonWidth+buttonSpacing+buttonStrokeHalf)
		if #planet.moons == 1 then
			extraX = extraX + (buttonWidth+buttonSpacing+buttonStrokeHalf)
		elseif #planet.moons == 2 then
			extraX = extraX + (buttonWidth+buttonSpacing+buttonStrokeHalf) / 2
		end
		for y, moon in ipairs(planet.moons) do
			ys = buttonLowY+(buttonHeight+buttonSpacing+buttonStrokeHalf)

			middle =	screenWidth / 2

			xs =  middle - ((buttonWidth / 2) * #planet.moons) + ((y-1) * (buttonWidth+buttonSpacing+buttonStrokeHalf)-buttonSpacing)

			--			xs = 10 + (shift * (buttonWidth+buttonSpacing+buttonStrokeHalf)) + extraX

			local button = {id = y, planet = moon, name = planet.name.." "..moon.name,  y=ys, x=xs}
			moon.button = button
			moon.sourcePlanet = planet
			moon.mapCoords = {x = mapX(moon),y = mapY(moon), z = mapZ(moon)}
			moon.fullname = planet.fullname.." "..moon.name
			shift = shift + 1
		end
	end
end

mapSize = 100

function updateStyle()
	style = [[<style>.circle {stroke: #]]..preset.planetEdgeColor..[[;stroke-width: 0.3vh;stroke-opacity: 0.9;fill-opacity: 0;}.planet {stroke: black;stroke-width: 1;}text {font-family: Arial,sans-serif, Helvetica;stroke-width: 0;font-weight: bold;}.btext {font-size: 5vh;}.bdtext {font-size: 4vh;text-anchor: end;}.minitext {fill: #]]..preset.planetNameColor..[[;}.mediumtext {fill: white;font-size: 5vh;fill: #]]..preset.miniTextColor..[[;}</style>]]
end

updateStyle()

function matmul(projection, vector)
	x = (projection[1][1] * vector.x) + (projection[1][2] * vector.y) + (projection[1][3] * vector.z)
	y = (projection[2][1] * vector.x) + (projection[2][2] * vector.y) + (projection[2][3] * vector.z)
	z = (projection[3][1] * vector.x) + (projection[3][2] * vector.y) + (projection[3][3] * vector.z)
	return {x = x, y = y, z = z}
end

function compare(a,b)
	return a.z > b.z
end

orDistance = 200

function toScreenCordsX(value)
	if value == nill then
		return 0
	end
	return value * 100 / screenWidth
end

function toScreenCordsY(value)
	if value == nill then
		return 0
	end
	return value * 100 / screenHeight
end

function toScreenCords(value)
	if value == nill then
		return 0
	end
	return value * 100 / screenWidth
end

function planetByName(name)
	for i, planet in ipairs(planets) do
		if planet.name == name then
			return planet
		end
		if planet.moons ~= nill then
			for y, moon in ipairs(planet.moons) do
				-- checking by formatted moon name which includes planet name
				if moon.button.name == name then
					return moon
				end
			end
		end
	end
	return nill
end

function getSuDistance(center)
	return tonumber(string.format("%.2f", math.sqrt((globalLoc.x-center.x)^2+(globalLoc.y-center.y)^2+(globalLoc.z-center.z)^2)/200000))
end

function getSuDistancePoints(fromVector, center)
	return tonumber(string.format("%.2f", math.sqrt((fromVector.x-center.x)^2+(fromVector.y-center.y)^2+(fromVector.z-center.z)^2)/200000))
end

function getRoute(toPlanet)

	distance = getSuDistance(toPlanet.center)
	if distance <= 500 then
		return {toPlanet}
	end

	primary = {}

	for i, planet in ipairs(planets) do
		distance = getSuDistance(planet.center)
		if distance <= 500 then
			table.insert(primary, planet)
		end

		for i, moon in ipairs(planet.moons) do
			distance = getSuDistance(moon.center)
			if distance <= 500 then
				table.insert(primary, moon)
			end
		end
	end



	local newDistance = 400000
	local endPlanets = {}

	for i, primaryPlanet in ipairs(primary) do
		distance = getSuDistancePoints(primaryPlanet.center, toPlanet.center)
		if distance <= 500 then
			total = (getSuDistance(primaryPlanet.center)+distance)
			if total < newDistance then
				newDistance = total
				endPlanets[1] = primaryPlanet
				endPlanets[2] = toPlanet
			end
		end
	end
	return endPlanets, newDistance
end

function convertTime(t)
	if t == nil then
		return ""
	end
	hours = 0
	minutes = t
	seconds = 0
	if t > 60 then
		hours = math.floor(t / 60)
	end

	if (hours > 24) then
		return "-"
	end


	if hours > 0 then
		minutes =  math.floor(t - (hours * 60))
	else
		minutes =  math.floor(t)
	end

	seconds = (t - (hours * 60) - minutes)
	seconds = math.floor(seconds * 60)

	endText = minutes.."min "..seconds.."sec"
	if hours > 0 then
		endText =  hours.."h "..endText
	end
	return endText
end

updateCounter = 30

function update(auto)
	updateCounter = updateCounter + 1
	if auto and updateCounter < 1 / updateInterval then
		return
	end
end

function updateButtons(auto)

	updateCounter = updateCounter + 1

	if auto and updateCounter < 1 / updateInterval then
		return
	end

	updateCounter = 0

	if warpdrive then
		local decoded = json.decode(warpdrive.getData())
		local warpDriveDestination = decoded.destination

		if warpDriveDestination == "Sanctuary" then
			warpDriveDestination = "Alioth "..warpDriveDestination;
		end

		if warpDriveDestinationPlanet == nill or warpDriveDestinationPlanet.fullname ~= warpDriveDestination then


			warpDriveDestinationPlanet = planetByName(warpDriveDestination)


			if warpDriveDestinationPlanet ~= nill then

				for _,screenObject in ipairs(screens) do
					screenObject.selectedPlanet = warpDriveDestinationPlanet
				end
			end
		end
		warpDriveMath = tonumber(Split(decoded.cellCount, " / ")[2])
		warpDriveCells =  tonumber(Split(decoded.cellCount, " / ")[1])
	end

	if core then
		shipVelocity = vec3(core.getVelocity()):len() * 3.6
	end

	constructWeight = math.ceil(core.getConstructMass() / 1000)

	if constructWeight < 2 and shipWeight > 2 then
		constructWeight = shipWeight
	end

	for _,screenObject in ipairs(screens) do

		local selectedPlanet = screenObject.selectedPlanet

		if selectedPlanet == nill and warpDriveDestinationPlanet ~= nill then
			screenObject.selectedPlanet = warpDriveDestinationPlanet
			selectedPlanet = warpDriveDestinationPlanet
		end

		if selectedPlanet == nill then
			calculatedDist = 0
		else
			calculatedDist = getSuDistance(selectedPlanet.center)
		end


		if calculatedDist > 500 then
			screenObject.route, calculatedDist = getRoute(selectedPlanet)
			newDistance = calculatedDist
		else
			screenObject.route = {selectedPlanet}
		end

		if core then
			--			aepx = 0.0002466
			aepx = 0.00025
			if warpDriveMath ~=nill and screenObject.selectedPlanet == warpDriveDestinationPlanet then
				warpmath = warpDriveMath
				warpmathBack = math.floor((screenObject.extraWeight)  *  calculatedDist * aepx)
				warpmathBack = warpmath + warpmathBack
			else



				--24.5 = 1000 * (100-2) * 0.00025
				-- (100-2) = 24.5 / 1000 / 0.00025

				warpmath = math.floor((constructWeight)  *  (calculatedDist-2) * aepx)
				warpmathBack = math.floor((constructWeight+screenObject.extraWeight)  *  (calculatedDist-2) * aepx)
			end
			if constructWeight+screenObject.extraWeight < 0 then
				screenObject.extraWeight = -constructWeight
			end
		else
			warpmath = 0
			warpmathBack = 0
		end


		if warpmath < 1 then
			warpmath = 1
		end

		if warpmathBack < 1 then
			warpmathBack = 1
		end

		approxSpeed = ""
		predictedSpeed = shipVelocity
		if shipVelocity <= 100 then
			approxSpeed = "*"
			if calculatedDist < 3 then
				predictedSpeed = 8000
			elseif calculatedDist < 10  then
				predictedSpeed = 10000
			elseif calculatedDist < 20  then
				predictedSpeed = 20000
			else
				predictedSpeed = 29900
			end
		end

		shipVelocityFormat = string.format("%.0f", predictedSpeed)




		lessWarpDistance = (warpmath - 1) / constructWeight / aepx
		lessWarpWeight = (warpmath - 1) / (calculatedDist-2) / aepx




		time_to_distance = string.format("%.2f", calculatedDist * 200 / ( predictedSpeed ) * 60)
		dist = string.format("%.0f", calculatedDist * 200)



		html = [[<svg width="100%" height="100%" viewBox="0 0 ]]..screenWidth..[[ ]]..screenHeight..[[">]]

		if screenObject.mapViewState == 1 then
			for i, planet in ipairs(planets) do
				textColor = preset.buttonTInactiveColor
				backColor = preset.buttonBInactiveColor

				if (screenObject.selectedPlanet == planet or screenObject.selectedPlanet ~=nill and screenObject.selectedPlanet.sourcePlanet == planet) then
					textColor = preset.buttonTActiveColor
					backColor = preset.buttonBActiveColor
				end



				if (warpDriveDestinationPlanet ~= nill and (warpDriveDestinationPlanet == planet or warpDriveDestinationPlanet.sourcePlanet == planet)) then
					textColor = preset.buttonTWarpInactiveColor
					if (screenObject.selectedPlanet == planet or screenObject.selectedPlanet.sourcePlanet == planet) then
						textColor = preset.buttonTWarpActiveColor
					end
				end

				distanceToPlanet = getSuDistance(planet.center)

				borderColor = preset.buttonBorderColor

				if screenObject.hover == planet.button then
					borderColor = preset.buttonBorderHoverColor
				end

				html = html..[[<rect rx="0" height="]]..buttonHeight..[[" width="]]..buttonWidth..[[" y="]]..planet.button.y..[[" x="]]..planet.button.x..[[" stroke-width="]]..buttonStroke..[[" stroke="#]]..borderColor..[[" fill="#]]..backColor..[["/>]]
				html = html..[[<text class="btext" y="]]..(planet.button.y+(buttonHeight/2)+15-buttonStroke*2)..[[" x="]]..(planet.button.x+10)..[[" fill="#]]..textColor..[[">]]..planet.button.name..[[</text>]]
				html = html..[[<text class="bdtext" y="]]..(planet.button.y+(buttonHeight/2)+15-buttonStroke*2)..[[" x="]]..(planet.button.x-10+buttonWidth)..[[" fill="#]]..textColor..[[">]]..string.format("%.1f", distanceToPlanet)..[[</text>]]
			end

			if screenObject.selectedPlanet ~= nill then

				moons = screenObject.selectedPlanet.moons

				if screenObject.selectedPlanet.sourcePlanet ~= nill then
					moons = screenObject.selectedPlanet.sourcePlanet.moons
				else
					moons = screenObject.selectedPlanet.moons
				end

				for i, moon in ipairs(moons) do

					textColor = preset.buttonTInactiveColor
					backColor = preset.buttonBInactiveColor
					if (screenObject.selectedPlanet == moon) then
						textColor = preset.buttonTActiveColor
						backColor = preset.buttonBActiveColor
					end

					if (warpDriveDestinationPlanet == moon) then
						textColor = preset.buttonTWarpInactiveColor
						if (screenObject.selectedPlanet == moon) then
							textColor = preset.buttonTWarpActiveColor
						end
					end

					calculatedDist = getSuDistance(moon.center)


					borderColor = preset.buttonBorderColor

					if screenObject.hover == moon.button then
						borderColor = preset.buttonBorderHoverColor
					end

					html = html..[[<rect rx="0" height="]]..buttonHeight..[[" width="]]..buttonWidth..[[" y="]]..(moon.button.y)..[[" x="]]..(moon.button.x)..[[" stroke-width="]]..buttonStroke..[[" stroke="#]]..borderColor..[[" fill="#]]..backColor..[["/>]]
					html = html..[[<text class="btext" y="]]..(moon.button.y+(buttonHeight/2)+15-buttonStroke*2)..[[" x="]]..(moon.button.x+10)..[[" fill="#]]..textColor..[[">]]..moon.name..[[</text>]]
					html = html..[[<text class="bdtext" y="]]..(moon.button.y+(buttonHeight/2)+15-buttonStroke*2)..[[" x="]]..(moon.button.x-10+buttonWidth)..[[" fill="#]]..textColor..[[">]]..string.format("%.1f", calculatedDist)..[[</text>]]
				end
			end


			textColor = preset.buttonTInactiveColor

			for i, button in ipairs(weightScreenButtons) do

				backColor = preset.buttonBInactiveColor
				if screenObject.weightButtonClicked == button and screenObject.mouseDown then
					backColor = "30786B"
				end

				borderColor = preset.buttonBorderColor

				if screenObject.hover == button then
					borderColor = preset.buttonBorderHoverColor
				end

				html = html..[[<rect rx="0" height="]]..buttonHeight..[[" width="]]..button.width..[[" y="]]..button.y..[[" x="]]..button.x..[[" stroke-width="]]..buttonStroke..[[" stroke="#]]..borderColor..[[" fill="#]]..backColor..[["/>]]

				change = button.change
				if change > 0 then
					change = "+"..change
				end
				html = html..[[<text class="btext" y="]]..(button.y+(buttonHeight/2)+15-buttonStroke*2)..[[" x="]]..(button.x+5)..[[" fill="#]]..textColor..[[">]]..change..[[</text>]]
			end



			borderColor = preset.buttonBorderColor

			if screenObject.hover == presetButton then
				borderColor = preset.buttonBorderHoverColor
			end

			html = html..[[<rect rx="0" height="]]..presetButton.height..[[" width="]]..presetButton.width..[[" y="]]..presetButton.y..[[" x="]]..presetButton.x..[[" stroke-width="]]..buttonStroke..[[" stroke="#]]..borderColor..[[" fill="#]]..preset.buttonBInactiveColor..[["/>]]
			html = html..[[<text text-anchor="middle" class="planet" font-size="3vh" y="]]..(presetButton.y+(presetButton.height/2)+10-buttonStroke*2)..[[" x="]]..(presetButton.x+(presetButton.width/2))..[[" fill="#]]..textColor..[[">]]..presetButton.preset..[[</text>]]

		end

		totalCells = warpmath+warpmathBack


		--		if string.len(warpCostColor) < 3 then
		--			wrpCostColor = "#9cfd80"
		--
		--			if warpDriveCells ~= nill then
		--				if totalCells <= warpDriveCells - 10 then
		--					wrpCostColor = "#08f600"
		--				elseif totalCells >= warpDriveCells - 2 and totalCells < warpDriveCells then
		--					wrpCostColor = "#ceffc0"
		--				elseif totalCells == warpDriveCells then
		--					wrpCostColor = "#fcfd80"
		--				elseif totalCells > warpDriveCells then
		--					wrpCostColor = "#ff0000"
		--				end
		--			end
		--		else
		wrpCostColor = preset.warpCostColor
		--		end


		if warpDriveCells ~= nill then
			totalCells = warpDriveCells.." / "..totalCells
		else
			totalCells = totalCells
		end


		if screenObject.mapViewState ~= 2 then
			if screenObject.route ~= nill and #screenObject.route > 1 then
				routeY = buttonLowY + buttonHeight*3+buttonSpacing
				routeX = "1%"
				routeAnchor = "start"

				if screenObject.mapViewState == 3 or screenObject.mapViewState == 4 then
					routeX = "99%"
					routeY = screenHeight-70
					routeAnchor = "end"
				end

				html = html..[[<text text-anchor="]]..routeAnchor..[[" class="mediumtext" y="]]..(routeY+60)..[[" x="]]..routeX..[[">New Su: ]]..newDistance..[[</text>]]
				fromName = screenObject.route[1].button.name
				if screenObject.route[1].sourcePlanet == nill then
					fromName = screenObject.route[1].name
				end
				toName = screenObject.route[2].button.name
				if screenObject.route[2].sourcePlanet == nill then
					toName = screenObject.route[2].name
				end
				html = html..[[<text text-anchor="]]..routeAnchor..[[" class="mediumtext" y="]]..(routeY)..[[" x="]]..routeX..[[">]]..fromName..[[</text>]]
				html = html..[[<text text-anchor="]]..routeAnchor..[[" class="mediumtext" y="]]..(routeY+30)..[[" x="]]..routeX..[[">]]..toName..[[</text>]]
			end

			html = html..[[<text class="mediumtext" y="540" x="1%">Dist: ]]..dist..
				[[ km</text><text class="mediumtext" y="570" x="1%">Vel: ]]..approxSpeed..shipVelocityFormat..
				[[ km/h</text><text class="mediumtext" y="600" x="1%">TTD: ]]..approxSpeed..convertTime(tonumber(time_to_distance))..
				[[</text>]]
		end

		if screenObject.mapViewState == 1 then
			html = html..[[<text text-anchor="end" class="mediumtext" y="200" x="99%">Warp Cost: ]]..warpmath..
				[[</text><text text-anchor="end" class="mediumtext" y="230" x="99%">Back Cost: ]]..warpmathBack..
				[[</text><text text-anchor="end" class="mediumtext" y="260" x="99%" style="fill:#]]..wrpCostColor..
				[[">Total: ]]..totalCells..[[</text>]]..




				[[<text text-anchor="end" class="mediumtext" y="310" x="99%">TLOC</text>]]..
				[[<text text-anchor="end" class="mediumtext" y="340" x="99%">]]..string.format("%.2f", calculatedDist-lessWarpDistance)..[[SU</text>]]..
				[[<text text-anchor="end" class="mediumtext" y="370" x="99%" style="fill:#]]..wrpCostColor..[[">]]..string.format("%.2f",constructWeight-lessWarpWeight)..[[T</text>]]..


				[[<text text-anchor="end" class="mediumtext" y="530" x="99%">Weight: ]]..constructWeight..
				[[ T</text><text text-anchor="end" class="mediumtext" y="560" x="99%">Back Weight: ]]..math.floor(constructWeight+screenObject.extraWeight)..
				[[ T</text>]]
		elseif screenObject.mapViewState == 4 then
			html = html..[[<text class="mediumtext" y="30" x="1%">Warp Cost: ]]..warpmath..[[</text>]]..
				[[<text class="mediumtext" y="60" x="1%">Back Cost: ]]..warpmathBack..[[</text>]]..
				[[<text class="mediumtext" y="90" x="1%" style="fill:#]]..wrpCostColor..[[">Total: ]]..totalCells..[[</text>]]..
				[[<text text-anchor="end" class="mediumtext" y="30" x="99%">Weight: ]]..constructWeight..[[ T</text>]]..
				[[<text text-anchor="end" class="mediumtext" y="60" x="99%">Back Weight: ]]..math.floor(constructWeight+screenObject.extraWeight)..[[ T</text>]]


			html = html..[[<text class="mediumtext" y="130" x="1%">TLOC</text>]]..
				[[<text class="mediumtext" y="160" x="1%">]]..string.format("%.2f", calculatedDist-lessWarpDistance)..[[SU</text>]]..
				[[<text class="mediumtext" y="190" x="1%" style="fill:#]]..wrpCostColor..[[">]]..string.format("%.2f",constructWeight-lessWarpWeight)..[[T</text>]]


		end

		html = html ..[[</svg>]]
		if screenObject.mapButtonContentId == nill then
			screenObject.mapButtonContentId = screenObject.screen.addContent(0, 0, html)
		else
			screenObject.screen.resetContent(screenObject.mapButtonContentId, html)
		end
	end
end

function getPointOnMap(rotationX, rotationY, rotationZ, screenObject, vector)
	point = {x = vector.x*screenObject.scale - screenObject.mapCenterPoint.x*screenObject.scale, y = vector.y*screenObject.scale - screenObject.mapCenterPoint.y*screenObject.scale, z = vector.z*screenObject.scale - screenObject.mapCenterPoint.z*screenObject.scale}

	point =  matmul(rotationZ, point)
	point =  matmul(rotationY, point)
	point =  matmul(rotationX, point)
	distance = distance * screenObject.scale
	z = 1 - (point.z)/400
	--  if z < 0.2 then
	--    z = 0.2
	--  end
	--  if z > 1 then
	--    z = 1
	--  end
	projection = {
		{1, 0, 0},
		{0, 1, 0},
		{0, 0, 1}
	}
	point =  matmul(projection, point)
	return {x = point.x + screenObject.screenCenterX, y = point.y + screenObject.screenCenterY, z = point.z, planet = planet, r = 5}
end

function updateScreen3d(screenObject, auto)

	globalLoc = vec3(core.getConstructWorldPos())
	--   globalLoc = vec3(-94134464.000, 12765536.000, -3634464.000)
	constructLoc  = {x = globalLoc.x/400000, y = (globalLoc.y/400000), z = globalLoc.z/400000}

	updateSC3d(screenObject, auto)

end

function update3d(auto)

	globalLoc = vec3(core.getConstructWorldPos())
	--   globalLoc = vec3(-94134464.000, 12765536.000, -3634464.000)
	constructLoc  = {x = globalLoc.x/400000, y = (globalLoc.y/400000), z = globalLoc.z/400000}

	for _,screenObject in ipairs(screens) do
		updateSC3d(screenObject, auto)
	end
end

function updateSC3d(screenObject, auto)

	--		  screenObject.mapCenterPoint = {x = globalLoc.x/400000, y = (globalLoc.y/400000), z = globalLoc.z/400000}

	if screenObject.mapViewState ~= 1 then
		screenObject.screenCenterX = screenWidth / 2
		screenObject.screenCenterY = screenHeight / 2
		screenObject.scale = screenObject.zoomScale
	else
		screenObject.screenCenterX = screenWidth / 2
		screenObject.screenCenterY = screenHeight - (screenHeight / 2.7)
		screenObject.scale = 1
	end

	--    if auto then
	--      screenObject.angle = screenObject.angle + 0.01
	--      screenObject.pitch = screenObject.pitch + 0.01
	--      screenObject.yaw = screenObject.yaw + 0.01
	--    end

	--    screenObject.scale = screenObject.scale + 0.05

	cosX = math.cos(screenObject.angle)
	sinX = math.sin(screenObject.angle)
	rotationX = {
		{1, 0, 0},
		{0, cosX, -sinX},
		{0, sinX, cosX}
	}

	cosY = math.cos(screenObject.pitch)
	sinY = math.sin(screenObject.pitch)
	rotationY = {
		{cosY, 0, -sinY},
		{0, 1, 0},
		{sinY, 0, cosY}
	}

	cosZ = math.cos(screenObject.yaw)
	sinZ = math.sin(screenObject.yaw)
	rotationZ = {
		{cosZ, -sinZ, 0},
		{sinZ, cosZ, 0},
		{0, 0, 1}
	}

	html = style..[[<svg width="100%" height="100%" viewBox="0 0 ]]..screenWidth..[[ ]]..screenHeight..[[">]]



	html = html..[[<rect fill="#]]..preset.backGroundColor..[[" height="]]..screenHeight..[[" width="]]..screenWidth..[[" y="0" x="0"/>]]

	newPoints = {}

	screenObject.planetScreen = {}

	for i, planet in ipairs(planets) do

		point = {x = planet.mapCoords.x*screenObject.scale - screenObject.mapCenterPoint.x*screenObject.scale, y = planet.mapCoords.y*screenObject.scale - screenObject.mapCenterPoint.y*screenObject.scale, z = planet.mapCoords.z*screenObject.scale - screenObject.mapCenterPoint.z*screenObject.scale}


		--      point = getPointOnMap(rotationX, rotationY, rotationZ, screenObject, point)

		point =  matmul(rotationZ, point)
		point =  matmul(rotationY, point)
		point =  matmul(rotationX, point)

		distance = orDistance*screenObject.scale

		z = 1 - (point.z)/400

		projection = {
			{1, 0, 0},
			{0, 1, 0},
			{0, 0, 1}
		}
		point =  matmul(projection, point)

		r = 10 - point.z/50
		font = 6 - (0.8 * (point.z/10 + mapSize*(screenObject.scale+1)) / distance)

		--    if planet.name == "Symeon" then
		--      system.print(point.z.." "..r.." "..screenObject.scale.. "  ".. font)
		--    end

		if r < 5 then
			r = 5
		end
		if r > 15 then
			r = 15
		end

		--      if font < 2 then
		--      font = 3
		--      end


		newPoints[i] = {x = point.x + screenObject.screenCenterX, y = point.y + screenObject.screenCenterY, z = point.z, planet = planet, r = r, font = font}


		table.insert(screenObject.planetScreen,planet.button.id, {x = newPoints[i].x, y = newPoints[i].y})


		if planet.drawZero then
			newPoints[i].zeroPoint = getPointOnMap(rotationX, rotationY, rotationZ, screenObject, {x = planet.mapCoords.x, y = planet.mapCoords.y, z = 0})
		end

	end

	table.sort(newPoints, compare)

	degreeY = -(screenObject.pitch * (180/math.pi))
	degreeX = screenObject.angle * (180/math.pi)
	degreeZ = -(screenObject.yaw * (180/math.pi))

	if  degreeY < -360 then
		screenObject.pitch = 0
	end

	if  degreeX > 360 then
		screenObject.angle = 0
	end

	if  degreeZ > 360 then
		screenObject.yaw = 0
	end

	rotationSide = getPointOnMap(rotationX, rotationY, rotationZ, screenObject, {x=0, y = 0, z= 10})

	mapStrokeColor = preset.mapCircleColor

	if rotationSide.z < 0 then
		mapStrokeColor = preset.mapBCircleColor
	end


	opacity = 0.3

	if screenObject.hover == "circle" then
		--			mapStrokeColor = preset.buttonBorderHoverColor
		opacity = 0.6
	end

	html = html..[[<g fill="none" stroke-width="]]..mapCircleThickness..[[" style="stroke: #]]..mapStrokeColor..[[; stroke-opacity: ]]..opacity..[[; fill-opacity:0.3; transform-origin: ]]..toScreenCordsX(screenObject.screenCenterX)..[[% ]]..toScreenCordsY(screenObject.screenCenterY)..[[% 0px;transform: rotateX(]]..degreeX..[[deg) rotateY(]]..degreeY..[[deg) rotateZ(]]..degreeZ..[[deg);">]]
	html = html..[[<circle cx="]]..(toScreenCordsX(screenObject.screenCenterX))..[[%" cy="]]..(toScreenCordsY(screenObject.screenCenterY))..[[%" r="]]..toScreenCords((SU100*6)*screenObject.scale)..[[%"></circle>]]
	html = html..[[<circle cx="]]..(toScreenCordsX(screenObject.screenCenterX))..[[%" cy="]]..(toScreenCordsY(screenObject.screenCenterY))..[[%" r="]]..toScreenCords((SU100*5)*screenObject.scale)..[[%"></circle>]]
	html = html..[[<circle cx="]]..(toScreenCordsX(screenObject.screenCenterX))..[[%" cy="]]..(toScreenCordsY(screenObject.screenCenterY))..[[%" r="]]..toScreenCords((SU100*4)*screenObject.scale)..[[%"></circle>]]
	html = html..[[<circle cx="]]..(toScreenCordsX(screenObject.screenCenterX))..[[%" cy="]]..(toScreenCordsY(screenObject.screenCenterY))..[[%" r="]]..toScreenCords((SU100*3)*screenObject.scale)..[[%"></circle>]]
	html = html..[[<circle cx="]]..(toScreenCordsX(screenObject.screenCenterX))..[[%" cy="]]..(toScreenCordsY(screenObject.screenCenterY))..[[%" r="]]..toScreenCords((SU100*2)*screenObject.scale)..[[%"></circle>]]
	html = html..[[<circle cx="]]..(toScreenCordsX(screenObject.screenCenterX))..[[%" cy="]]..(toScreenCordsY(screenObject.screenCenterY))..[[%" r="]]..toScreenCords(SU100*screenObject.scale)..[[%"></circle>]]
	html = html..[[</g>]]

	--    degreeY = degreeY -45
	--    html = html..[[<circle cx="]]..(toScreenCordsX(screenObject.screenCenterX))..[[%" cy="]]..(toScreenCordsY(screenObject.screenCenterY))..[[%" r="]]..toScreenCords(250)..[[%" fill="none" stroke-width="0.8em" style="stroke: ]]..mapStrokeColor..[[; stroke-opacity: 0.6; fill-opacity:0.8; transform-origin: 50% 50% 0px;transform: rotateX(]]..degreeX..[[deg) rotateY(]]..degreeY..[[deg) rotateZ(]]..degreeZ..[[deg);"></circle>]]


	if showSafeZone then
		constructPoint = getPointOnMap(rotationX, rotationY, rotationZ, screenObject, safeZoneCenter)
		html = html..[[<circle cx="]]..(toScreenCordsX(constructPoint.x))..[[%" cy="]]..(toScreenCordsY(constructPoint.y))..[[%" r="]]..toScreenCords(safeZoneSize*screenObject.scale)..[[%" class="circle" style="fill:#]]..preset.mapConstructColor..[[; stroke: #]]..preset.mapConstructSColor..[[; stroke-opacity: 0.3; fill-opacity: 0.2"></circle>]]
	end

	--		constructPoint = getPointOnMap(rotationX, rotationY, rotationZ, screenObject, edge)
	--		html = html..[[<circle cx="]]..(toScreenCordsX(constructPoint.x))..[[%" cy="]]..(toScreenCordsY(constructPoint.y))..[[%" r="]]..toScreenCords(2)..[[%" class="circle" style="fill:]]..mapConstructColor..[[; stroke: ]]..mapConstructSColor..[[; stroke-opacity: 0.3; fill-opacity: 0.2"></circle>]]



	if screenObject.route ~= nill then
		previousPoint = constructLoc
		for i, planet in ipairs(screenObject.route) do
			if planet ~= nill then

				originPoint = getPointOnMap(rotationX, rotationY, rotationZ, screenObject, previousPoint)
				distinationPoint = getPointOnMap(rotationX, rotationY, rotationZ, screenObject, planet.mapCoords)

				dashArray = "40 10 30 10 20 10"
				if screenObject.timer > 2 then
					screenObject.timer = 0
				end
				screenObject.timer = screenObject.timer + 1

				html = html..[[<line stroke-linecap="undefined" stroke-linejoin="undefined" animation="dash 5s linear" stroke-dasharray="]]..dashArray..[[" y2="]]..toScreenCordsY(distinationPoint.y)..[[%" x2="]]..toScreenCordsX(distinationPoint.x)..[[%" y1="]]..toScreenCordsY(originPoint.y)..[[%" x1="]]..toScreenCordsX(originPoint.x)..[[%" stroke-opacity="0.9" stroke-width="5" stroke="#]]..preset.pathColor..[[" fill="none" fill-opacity="0"/>]]

			end
			previousPoint = planet.mapCoords
		end
	end

	for i, planetPoint in ipairs(newPoints) do
		if planetPoint.planet ~= nill then

			if planetPoint.zeroPoint ~= nill then
				html = html..[[<line stroke-linecap="undefined" stroke-linejoin="undefined" y2="]]..toScreenCordsY(planetPoint.y)..[[%" x2="]]..toScreenCordsX(planetPoint.x)..[[%" y1="]]..toScreenCordsY(planetPoint.zeroPoint.y)..[[%" x1="]]..toScreenCordsX(planetPoint.zeroPoint.x)..[[%" stroke-width="2" stroke-opacity="0.3" stroke="#]]..preset.planetOffsetColor..[[" fill="none" fill-opacity="0.5"/>]]
			end

			plColor = planetPoint.planet.color

			if string.len(preset.planetColor) > 2 then
				plColor = preset.planetColor;
			end

			local planetSize = planetPoint.r

			if screenObject.mapViewState ~= 1 then
				planetSize = planetSize*screenObject.zoomScale
			end

			local fontSize = planetPoint.font
			if screenObject.hover ~= nill and screenObject.hover == planetPoint.planet then
				planetSize = planetSize * 1.5
				fontSize = fontSize * 1.5
			end
			html = html..[[<circle cx="]]..(toScreenCordsX(planetPoint.x))..[[%" cy="]]..(toScreenCordsY(planetPoint.y))..[[%" r="]]..toScreenCords(planetSize)..[[%" class="circle" style="fill:#]]..plColor..[[; stroke-opacity: 0.5; fill-opacity: 1"></circle>]]
			html = html..[[<text x="]]..tostring(toScreenCordsX(planetPoint.x))..[[%" y="]]..tostring(toScreenCordsY( planetPoint.y))..[[%" class="minitext" font-family="Arial" font-size="]]..fontSize..[[vh" fill="white">]]..planetPoint.planet.name..[[</text>]]
		end
	end

	constructPoint = getPointOnMap(rotationX, rotationY, rotationZ, screenObject, constructLoc)
	html = html..[[<circle cx="]]..(toScreenCordsX(constructPoint.x))..[[%" cy="]]..(toScreenCordsY(constructPoint.y))..[[%" r="]]..toScreenCords(constructPoint.r)..[[%" class="circle" style="fill:#]]..preset.mapConstructColor..[[; stroke: ]]..preset.mapConstructSColor..[[; stroke-opacity: 0.5; fill-opacity: 1"></circle>]]

	html = html ..[[</svg>]]
	if screenObject.mapContentId == nill then
		screenObject.mapContentId = screenObject.screen.addContent(0, 0, html)
	else
		screenObject.screen.resetContent(screenObject.mapContentId, html)
	end
end

function evaluateButtons(x, y, pressDown, screen)
	for _,screenObject in ipairs(screens) do
		if  screenObject.screen.getId() == screen.getId() then

			screenObject.mouseDown = pressDown


			if pressDown then
				unit.setTimer("maprotate", updateMouseInterval)
			end

			clickCoordX = x * screenWidth
			clickCoordY = y * screenHeight

			if not pressDown then
				screenObject.weightButtonClicked = nill
			end

			--      if screenObject.mapViewState ~= 1 then
			for i, planet in ipairs(planets) do

				dpd = screenObject.planetScreen[planet.button.id]

				if clickCoordX > dpd.x-20 and clickCoordX < dpd.x+20 and clickCoordY > dpd.y-20 and clickCoordY < dpd.y+20 and pressDown then
					if screenObject.selectedPlanet == planet and pressDown then
						screenObject.selectedPlanet = nill
					elseif pressDown then
						screenObject.selectedPlanet = planet
					end
					screenObject.changeView = false
					update3d(false)
					updateButtons(false)
					return
				end
			end
			--      end

			if screenObject.mapViewState == 1 then
				--        for i, v in ipairs(activeMoons) do activeMoons[i] = nil end
				for i, planet in ipairs(planets) do
					if clickCoordX > planet.button.x-buttonStrokeHalf and clickCoordX < planet.button.x + buttonWidth+buttonStrokeHalf and clickCoordY > planet.button.y-buttonStrokeHalf and clickCoordY < planet.button.y + buttonHeight+buttonStrokeHalf then
						if screenObject.selectedPlanet == planet and pressDown then
							screenObject.selectedPlanet = nill
						elseif pressDown then
							screenObject.selectedPlanet = planet
						end
					end
				end

				if screenObject.selectedPlanet ~= nill then
					if screenObject.selectedPlanet.moons ~= nill then
						for i, moon in ipairs(screenObject.selectedPlanet.moons) do
							if clickCoordX > moon.button.x-buttonStrokeHalf and clickCoordX < moon.button.x + buttonWidth+buttonStrokeHalf and clickCoordY > moon.button.y-buttonStrokeHalf and clickCoordY < moon.button.y + buttonHeight+buttonStrokeHalf then
								screenObject.selectedPlanet = moon
							end
						end
					else
						for i, moon in ipairs(screenObject.selectedPlanet.sourcePlanet.moons) do
							if clickCoordX > moon.button.x-buttonStrokeHalf and clickCoordX < moon.button.x + buttonWidth+buttonStrokeHalf and clickCoordY > moon.button.y-buttonStrokeHalf and clickCoordY < moon.button.y + buttonHeight+buttonStrokeHalf then
								screenObject.selectedPlanet = moon
							end
						end

					end
				end

				if #weightScreenButtons >= 1 then
					for i, button in ipairs(weightScreenButtons) do
						if clickCoordX > button.x-buttonStrokeHalf and clickCoordX < button.x + button.width+buttonStrokeHalf and clickCoordY > button.y-buttonStrokeHalf and clickCoordY < button.y + buttonHeight+buttonStrokeHalf then
							if not pressDown then
								screenObject.extraWeight = screenObject.extraWeight + button.change
							else
								screenObject.weightButtonClicked = button
							end
						end
					end
				end

				if clickCoordX > presetButton.x-buttonStrokeHalf and clickCoordX < presetButton.x + presetButton.width+buttonStrokeHalf and clickCoordY > presetButton.y-buttonStrokeHalf and clickCoordY < presetButton.y + presetButton.height+buttonStrokeHalf then
					if not pressDown then
						presetButton.preset = presetButton.preset + 1
						if presetButton.preset > #presets then
							presetButton.preset = 1
						end
						savepreset()
						updatePreset()
						updateStyle()
						update3d(false)
						updateButtons(false)
					end
				end


			end

			if screenObject.changeView and not pressDown then
				if screenObject.mapViewState ~= 1 then
					screenObject.mapViewState = screenObject.mapViewState + 1
					if screenObject.mapViewState > 4 then
						screenObject.mapViewState = 1
					end
				else

					if clickCoordX > (screenWidth / 2) - 400 and  clickCoordX < (screenWidth / 2) + 400 and clickCoordY > (screenHeight / 3) and  clickCoordY < (screenHeight / 2) + 200 then
						screenObject.mapViewState = 2
					end
				end

				save(screenObject)
			end

			update3d(false)
			updateButtons(false)

			return
		end
	end
end

rotatelimit = 2

function mapRotate()

	local someOneHolding = false

	for _,screenObject in ipairs(screens) do
		if screenObject.mouseDown then
			someOneHolding = true
			changed = false;
			if (screenObject.screen.prevMouseX ~= nil and screenObject.screen.getMouseX() > 0 and screenObject.screen.getMouseY() > 0) then

				difX = (screenObject.screen.prevMouseX - screenObject.screen.getMouseX()*screenWidth)
				difY = (screenObject.screen.prevMouseY - screenObject.screen.getMouseY()*screenHeight)

				screenObject.screen.difX = difX
				screenObject.screen.difY = difY

				if (screenObject.screen.getMouseY() > 0.85 and screenObject.mapViewState ~= 1) then
					if (difX < 20 or difX > -20) then
						screenObject.yaw = screenObject.yaw + (difX / 100)
						changed = true
					end
					if changed then
						update3d(false)
					end
				elseif (screenObject.screen.getMouseX() < 0.15 and screenObject.mapViewState ~= 1) then
					if ((difY < 20 or difY > -20) and (difY > 0.8 or difY < -0.8)) then
						screenObject.angle = screenObject.angle - (difY / 200)
						changed = true
					end
					if changed then
						update3d(false)
					end
				elseif (screenObject.screen.getMouseY() < 0.15 and screenObject.mapViewState ~= 1) then
					if (difX < 20 or difX > -20) and (difX > 0.8 or difX < -0.8) then
						screenObject.pitch = screenObject.pitch - (difX / 200)
						changed = true
					end
					if changed then
						update3d(false)
					end
				else
					if (difX < 20 or difX > -20) and (difX > 1 or difX < -1) then
						screenObject.pitch = screenObject.pitch - (difX / 200)
						changed = true
					end

					if ((difY < 20 or difY > -20) and (difY > 1 or difY < -1)) then
						screenObject.angle = screenObject.angle - (difY / 200)
						changed = true
					end
					if changed then
						screenObject.changeView = false
						update3d(false)
					end
				end
			end


			if (screenObject.screen.getMouseX() > 0 and screenObject.screen.getMouseY() > 0)then
				screenObject.screen.prevMouseX = screenObject.screen.getMouseX()*screenWidth
				screenObject.screen.prevMouseY = screenObject.screen.getMouseY()*screenHeight
				if (changed) then
					screenObject.changeView = false
				end
			else
				screenObject.changeView = true
				screenObject.mouseDown = false
				screenObject.screen.prevMouseX = nill
				screenObject.screen.prevMouseY = nill
			end
		else

			screenObject.screen.prevMouseX = nill
			screenObject.screen.prevMouseY = nill

			if (screenObject.screen.difX ~= 0 or screenObject.screen.difY ~= 0) and screenObject.screen.difX ~= nill and screenObject.screen.difY ~= nill
				and (screenObject.screen.difX < -rotatelimit or screenObject.screen.difX > rotatelimit
				or (screenObject.screen.difY < -rotatelimit or screenObject.screen.difY > rotatelimit))
			then

				someOneHolding = true
				screenObject.screen.difX = screenObject.screen.difX / 1.2
				--				screenObject.screen.prevMouseX =screenObject.screen.prevMouseX+screenObject.screen.difX

				if screenObject.screen.difX > -rotatelimit and screenObject.screen.difX < rotatelimit then
					screenObject.screen.difX = 0
				end
				screenObject.screen.difY = screenObject.screen.difY / 1.2
				--        screenObject.screen.prevMouseY =screenObject.screen.prevMouseY+screenObject.screen.difY
				if screenObject.screen.difY > -rotatelimit and screenObject.screen.difY < rotatelimit then
					screenObject.screen.difY = 0
				end

				if screenObject.screen.difX == 0 and screenObject.screen.difY == 0 then
					someOneHolding = false
				end

				if (screenObject.screen.difX < 20 or screenObject.screen.difX > -20) and (screenObject.screen.difX > rotatelimit or screenObject.screen.difX < -rotatelimit) then
					screenObject.pitch = screenObject.pitch - (screenObject.screen.difX / 200)
					changed = true
				end

				if ((screenObject.screen.difY < 20 or screenObject.screen.difY > -20) and (screenObject.screen.difY > rotatelimit or screenObject.screen.difY < -rotatelimit)) then
					screenObject.angle = screenObject.angle - (screenObject.screen.difY / 200)
					changed = true
				end
				if changed then
					update3d(false)
				end



			else
				save(screenObject)
				screenObject.changeView = true
			end
		end
	end

	if not someOneHolding then
		saveAll()
		unit.stopTimer("maprotate")
	end
end

hovertimer = 1

zoomMax = 5
zoomMin = 0.8

function checkhover()
	looking = false
	for _,screenObject in ipairs(screens) do
		screenLooking = false
		local x = screenObject.screen.getMouseX()
		if x ~= -1 then
			local y = screenObject.screen.getMouseY()
			if y ~= -1 then


				if system.getMouseWheel() ~= 0 then
					screenObject.targetZoomScale = screenObject.targetZoomScale+(system.getMouseWheel()/10)
					if screenObject.targetZoomScale < zoomMin then
						screenObject.targetZoomScale = zoomMin
					end
					if screenObject.targetZoomScale > zoomMax then
						screenObject.targetZoomScale = zoomMax
					end
					update3d(screenObject, false)
					save(screenObject)
				end


				if screenObject.targetZoomScale ~= screenObject.zoomScale then
					zoomDif = screenObject.targetZoomScale - screenObject.zoomScale

					if zoomDif < 0.01 and zoomDif > -0.01 then
						screenObject.zoomScale = screenObject.targetZoomScale
					else
						zoomDif =zoomDif - ( zoomDif * 0.5)
						screenObject.zoomScale = screenObject.zoomScale + zoomDif
						updateScreen3d(screenObject, false)
					end
				end


				looking = true
				clickCoordX = x * screenWidth
				clickCoordY = y * screenHeight
				if hovertimer == 1 then
					unit.setTimer("hoverdetect", updateHoverInterval)
					hovertimer = updateHoverInterval
				end
				for i, planet in ipairs(planets) do
					dpd = screenObject.planetScreen[planet.button.id]
					if clickCoordX > dpd.x-20 and clickCoordX < dpd.x+20 and clickCoordY > dpd.y-20 and clickCoordY < dpd.y+20 then
						screenObject.hover = planet
						screenLooking = true
						update3d(false)
						return
					end
				end



				if screenObject.mapViewState == 1 then
					--        for i, v in ipairs(activeMoons) do activeMoons[i] = nil end
					for i, planet in ipairs(planets) do
						if clickCoordX > planet.button.x-buttonStrokeHalf and clickCoordX < planet.button.x + buttonWidth+buttonStrokeHalf and clickCoordY > planet.button.y-buttonStrokeHalf and clickCoordY < planet.button.y + buttonHeight+buttonStrokeHalf then
							screenObject.hover = planet.button
							screenLooking = true
							updateButtons(false)

						end
					end

					if screenObject.selectedPlanet ~= nill then
						if screenObject.selectedPlanet.moons ~= nill then
							for i, moon in ipairs(screenObject.selectedPlanet.moons) do
								if clickCoordX > moon.button.x-buttonStrokeHalf and clickCoordX < moon.button.x + buttonWidth+buttonStrokeHalf and clickCoordY > moon.button.y-buttonStrokeHalf and clickCoordY < moon.button.y + buttonHeight+buttonStrokeHalf then
									screenObject.hover = moon.button
									screenLooking = true
									updateButtons(false)
								end
							end
						else
							for i, moon in ipairs(screenObject.selectedPlanet.sourcePlanet.moons) do
								if clickCoordX > moon.button.x-buttonStrokeHalf and clickCoordX < moon.button.x + buttonWidth+buttonStrokeHalf and clickCoordY > moon.button.y-buttonStrokeHalf and clickCoordY < moon.button.y + buttonHeight+buttonStrokeHalf then
									screenObject.hover = moon.button
									screenLooking = true
									updateButtons(false)
								end
							end
						end
					end

					if #weightScreenButtons >= 1 then
						for i, button in ipairs(weightScreenButtons) do
							if clickCoordX > button.x-buttonStrokeHalf and clickCoordX < button.x + button.width+buttonStrokeHalf and clickCoordY > button.y-buttonStrokeHalf and clickCoordY < button.y + buttonHeight+buttonStrokeHalf then
								screenObject.hover = button
								screenLooking = true
								updateButtons(false)
							end
						end
					end

					if clickCoordX > presetButton.x-buttonStrokeHalf and clickCoordX < presetButton.x + presetButton.width+buttonStrokeHalf and clickCoordY > presetButton.y-buttonStrokeHalf and clickCoordY < presetButton.y + presetButton.height+buttonStrokeHalf then
						if not pressDown then
							screenObject.hover = presetButton
							screenLooking = true
							updateButtons(false)
						end
					end
				end

				if screenObject.mapViewState ~= 1 then

				elseif clickCoordX > (screenWidth / 2) - 400 and  clickCoordX < (screenWidth / 2) + 400 and clickCoordY > (screenHeight / 3) and  clickCoordY < (screenHeight / 2) + 200 then
					screenObject.hover = "circle"
					screenLooking = true
					update3d(false)
				end
			end
		end

		if screenObject.hover ~= nill and not screenLooking then
			screenObject.hover = nill
			update3d(false)
			updateButtons(false)
		end

		if not screenLooking then
			screenObject.hover = nill
		end

	end
	if not looking then
		unit.setTimer("hoverdetect", 1)
		hovertimer = 1
	end
end

for _,screenObject in ipairs(screens) do
	screenObject.screen.clear()
end
update3d(false)
updateButtons(false)
unit.setTimer("spacemap", updateInterval)
unit.setTimer("hoverdetect", 1)
unit.hide()
